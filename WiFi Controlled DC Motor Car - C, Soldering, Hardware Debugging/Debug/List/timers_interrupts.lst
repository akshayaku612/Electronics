###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          30/Nov/2021  21:13:12
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        D:\Akshay\NCSU\4th year\Fall 2021\ECE
#        306\Project\KamalapuramSridhar_Akshay\timers_interrupts.c
#    Command line  =  
#        -f C:\Users\aku_1\AppData\Local\Temp\EW5A71.tmp ("D:\Akshay\NCSU\4th
#        year\Fall 2021\ECE
#        306\Project\KamalapuramSridhar_Akshay\timers_interrupts.c" -lC
#        "D:\Akshay\NCSU\4th year\Fall 2021\ECE
#        306\Project\KamalapuramSridhar_Akshay\Debug\List" -o
#        "D:\Akshay\NCSU\4th year\Fall 2021\ECE
#        306\Project\KamalapuramSridhar_Akshay\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --debug -D__MSP430FR2355__ -e
#        --double=32 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./ --core=430X
#        --data_model=small -On --multiplier=32 --hw_workaround=CPU40
#        --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        D:\Akshay\NCSU\4th year\Fall 2021\ECE
#        306\Project\KamalapuramSridhar_Akshay\Debug\List\timers_interrupts.lst
#    Object file   =  
#        D:\Akshay\NCSU\4th year\Fall 2021\ECE
#        306\Project\KamalapuramSridhar_Akshay\Debug\Obj\timers_interrupts.r43
#
###############################################################################

D:\Akshay\NCSU\4th year\Fall 2021\ECE 306\Project\KamalapuramSridhar_Akshay\timers_interrupts.c
      1          // ------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the code to create the timer interrupts
      4          // It includes the Pragma vector and the ISR for all the timer interrupts
      5          //
      6          //  Akshay Kamalapuram Sridhar
      7          //  Oct 2021
      8          //  Built with IAR Embedded Workbench Version: V7.21.1
      9          // ------------------------------------------------------------------------------
     10          
     11          #include  "macros.h"

  #define end (8)
          ^
"D:\Akshay\NCSU\4th year\Fall 2021\ECE 306\Project\KamalapuramSridhar_Akshay\macros.h",211  Warning[Pe047]: 
          incompatible redefinition of macro "end" (declared at line 211)
     12          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x700
   \   union <unnamed> _A_ADCCTL0_L
   \                     _A_ADCCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x21a
   \   union <unnamed> _A_PAIE_L
   \                     _A_PAIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x392
   \   union <unnamed> _A_TB0CCR0_L
   \                     _A_TB0CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x394
   \   union <unnamed> _A_TB0CCR1_L
   \                     _A_TB0CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x396
   \   union <unnamed> _A_TB0CCR2_L
   \                     _A_TB0CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ae
   \   union <unnamed> _A_TB0IV_L
   \                     _A_TB0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d2
   \   union <unnamed> _A_TB1CCR0_L
   \                     _A_TB1CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d4
   \   union <unnamed> _A_TB1CCR1_L
   \                     _A_TB1CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ee
   \   union <unnamed> _A_TB1IV_L
   \                     _A_TB1IV_L:
   \   000000                DS8 2
     13          #include  "functions.h"
     14          
     15          extern unsigned int Time_Sequence;
     16          extern unsigned int Movement_Timer;
     17          extern unsigned int Counter_Timer;
     18          extern unsigned int Circle_Timer;
     19          extern unsigned int sw1_pressed_interrupt;
     20          extern unsigned int sw2_pressed_interrupt;
     21          extern volatile unsigned char update_display;
     22          extern unsigned int line_follower_state;
     23          extern unsigned int traverse_state;
     24          extern unsigned int circle_timer_flag;
     25          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          unsigned int debounce_counter=RESET_STATE;
   \                     debounce_counter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          unsigned int Movement_Timer_count=RESET_STATE;
   \                     Movement_Timer_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     28          unsigned int counter_timer_count=RESET_STATE;
   \                     counter_timer_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     29          unsigned int circle_timer_count=RESET_STATE;
   \                     circle_timer_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     30          unsigned int line_follower_timer_flag=RESET_STATE;
   \                     line_follower_timer_flag:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     31          unsigned int flag=RESET_STATE;
   \                     flag:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     32          unsigned int display_update_count=RESET_STATE;
   \                     display_update_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     33          unsigned int follow_flag=RESET_STATE;
   \                     follow_flag:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     34          unsigned int iot_ready=RESET_STATE;
   \                     iot_ready:
   \   000000                DS8 2
     35          
     36          
     37          // ------------------------------------------------------------------------------
     38          //
     39          //  Description: This file contains the code to create the timer interrupts
     40          // It includes the Pragma vector and the ISR for all the timer interrupts
     41          //
     42          //  Akshay Kamalapuram Sridhar
     43          //  Oct 2021
     44          //  Built with IAR Embedded Workbench Version: V7.21.1
     45          //
     46          //  ISR contains interrupt for the timer-sequence and state machine timer
     47          //
     48          // ------------------------------------------------------------------------------
     49          
     50          #pragma vector = TIMER0_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     51          __interrupt void Timer0_B0_ISR(void){
   \                     Timer0_B0_ISR:
     52          //------------------------------------------------------------------------------
     53          // TimerB0 0 Interrupt handler
     54          //----------------------------------------------------------------------------
     55            TB0CCR0 += TB0CCR0_INTERVAL; // Add Offset to TBCCR0
   \   000000   B250A8619203 ADD.W   #0x61a8, &0x392
     56            follow_flag=ALWAYS;
   \   000006   9243....     MOV.W   #0x1, &follow_flag
     57            iot_ready=ALWAYS;
   \   00000A   9243....     MOV.W   #0x1, &iot_ready
     58            if (Time_Sequence>limit_time) P2OUT |= DAC_ENB; // Value = High [enabled]
   \   00000E   B2906500.... CMP.W   #0x65, &Time_Sequence
   \   000014   0228         JNC     ??Timer0_B0_ISR_0
   \   000016   D2D30302     BIS.B   #0x1, &0x203
     59            if (Time_Sequence<iot_reset_time) {
   \                     ??Timer0_B0_ISR_0:
   \   00001A   A292....     CMP.W   #0x4, &Time_Sequence
   \   00001E   052C         JC      ??Timer0_B0_ISR_1
     60              P3OUT &= ~IOT_RESET;
   \   000020   F2C080002202 BIC.B   #0x80, &0x222
     61              iot_ready=RESET_STATE;
   \   000026   8243....     MOV.W   #0x0, &iot_ready
     62            }
     63            if (Time_Sequence<iot_reset_time) { 
   \                     ??Timer0_B0_ISR_1:
   \   00002A   A292....     CMP.W   #0x4, &Time_Sequence
   \   00002E   022C         JC      ??Timer0_B0_ISR_2
     64              iot_ready=RESET_STATE;
   \   000030   8243....     MOV.W   #0x0, &iot_ready
     65            }
     66            ++Time_Sequence;
   \                     ??Timer0_B0_ISR_2:
   \   000034   9253....     ADD.W   #0x1, &Time_Sequence
     67          //----------------------------------------------------------------------------
     68          }
   \   000038   0013         RETI
   \   00003A                REQUIRE _A_TB0CCR0_L
   \   00003A                REQUIRE _A_PAOUT_L
   \   00003A                REQUIRE _A_PBOUT_L
     69          
     70          // ------------------------------------------------------------------------------
     71          //
     72          //  Description: This file contains the code to create the timer interrupts
     73          // It includes the Pragma vector and the ISR for all the timer interrupts
     74          //
     75          //  Akshay Kamalapuram Sridhar
     76          //  Oct 2021
     77          //  Built with IAR Embedded Workbench Version: V7.21.1
     78          //
     79          //  ISR contains interrupts debounce switches and for updating the display
     80          //
     81          // ------------------------------------------------------------------------------
     82          
     83          #pragma vector=TIMER0_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     84          __interrupt void TIMER0_B1_ISR(void){ 
   \                     TIMER0_B1_ISR:
   \   000000   0F12         PUSH.W  R15
     85          //----------------------------------------------------------------------------
     86          // TimerB0 1-2, Overflow Interrupt Vector (TBIV) handler
     87          //----------------------------------------------------------------------------
     88            switch(__even_in_range(TB0IV,OVERFLOW)){
   \   000002   1F42AE03     MOV.W   &0x3ae, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for TIMER0_B1_ISR>_0`:
   \   000008   423C         JMP     ??TIMER0_B1_ISR_2
   \   00000A   063C         JMP     ??TIMER0_B1_ISR_7
   \   00000C   2A3C         JMP     ??TIMER0_B1_ISR_8
   \   00000E   3F3C         JMP     ??TIMER0_B1_ISR_2
   \   000010   3E3C         JMP     ??TIMER0_B1_ISR_2
   \   000012   3D3C         JMP     ??TIMER0_B1_ISR_2
   \   000014   3C3C         JMP     ??TIMER0_B1_ISR_2
   \   000016   3B3C         JMP     ??TIMER0_B1_ISR_2
     89              case RESET_STATE: break; // No interrupt
     90              case CCR1:
     91                  if (sw1_pressed_interrupt){
   \                     ??TIMER0_B1_ISR_7:
   \   000018   8293....     CMP.W   #0x0, &sw1_pressed_interrupt
   \   00001C   0F24         JEQ     ??TIMER0_B1_ISR_4
     92                    debounce_counter++;
   \   00001E   9253....     ADD.W   #0x1, &debounce_counter
     93                    if (debounce_counter>DEBOUNCE_LIMIT){
   \   000022   B2900B00.... CMP.W   #0xb, &debounce_counter
   \   000028   0928         JNC     ??TIMER0_B1_ISR_4
     94                      TB0CCR1 += TB0CCR1_INTERVAL;
   \   00002A   B25070179403 ADD.W   #0x1770, &0x394
     95                      P4IE |= SW1; // P4.6 interrupt enabled
   \   000030   E2D33B02     BIS.B   #0x2, &0x23b
     96                      debounce_counter=RESET_STATE;
   \   000034   8243....     MOV.W   #0x0, &debounce_counter
     97                      sw1_pressed_interrupt=RESET_STATE;
   \   000038   8243....     MOV.W   #0x0, &sw1_pressed_interrupt
     98                    }
     99                  }
    100                  if (sw2_pressed_interrupt){
   \                     ??TIMER0_B1_ISR_4:
   \   00003C   8293....     CMP.W   #0x0, &sw2_pressed_interrupt
   \   000040   2624         JEQ     ??TIMER0_B1_ISR_2
    101                    debounce_counter++;
   \   000042   9253....     ADD.W   #0x1, &debounce_counter
    102                    if (debounce_counter>DEBOUNCE_LIMIT){
   \   000046   B2900B00.... CMP.W   #0xb, &debounce_counter
   \   00004C   2028         JNC     ??TIMER0_B1_ISR_2
    103                      TB0CCR1 += TB0CCR1_INTERVAL;
   \   00004E   B25070179403 ADD.W   #0x1770, &0x394
    104                      P2IE |= SW2; // P2.6 interrupt enabled
   \   000054   F2D21B02     BIS.B   #0x8, &0x21b
    105                      debounce_counter=RESET_STATE;
   \   000058   8243....     MOV.W   #0x0, &debounce_counter
    106                      sw2_pressed_interrupt=RESET_STATE;
   \   00005C   8243....     MOV.W   #0x0, &sw2_pressed_interrupt
    107                    }
    108                  } 
    109                  break;
   \   000060   163C         JMP     ??TIMER0_B1_ISR_2
    110              case CCR2:
    111                  TB0CCR2 += TB0CCR2_INTERVAL;
   \                     ??TIMER0_B1_ISR_8:
   \   000062   B25010279603 ADD.W   #0x2710, &0x396
    112                  display_update_count++;
   \   000068   9253....     ADD.W   #0x1, &display_update_count
    113                  if (display_update_count>=second_count){
   \   00006C   B2900A00.... CMP.W   #0xa, &display_update_count
   \   000072   0428         JNC     ??TIMER0_B1_ISR_5
    114                    update_display = ALWAYS;
   \   000074   D243....     MOV.B   #0x1, &update_display
    115                    display_update_count = RESET_STATE;
   \   000078   8243....     MOV.W   #0x0, &display_update_count
    116                  }
    117                  flag=!flag;
   \                     ??TIMER0_B1_ISR_5:
   \   00007C   8293....     CMP.W   #0x0, &flag
   \   000080   0220         JNE     ??TIMER0_B1_ISR_6
   \   000082   5F43         MOV.B   #0x1, R15
   \   000084   013C         JMP     ??TIMER0_B1_ISR_3
   \                     ??TIMER0_B1_ISR_6:
   \   000086   4F43         MOV.B   #0x0, R15
   \                     ??TIMER0_B1_ISR_3:
   \   000088   4F4F         MOV.B   R15, R15
   \   00008A   824F....     MOV.W   R15, &flag
    118                  break;
    119              case OVERFLOW: // overflow
    120                  break;
    121              default: break;
    122            }
    123          //----------------------------------------------------------------------------
    124          }
   \                     ??TIMER0_B1_ISR_2:
   \   00008E   3F41         POP.W   R15
   \   000090   0013         RETI
   \   000092                REQUIRE _A_TB0CCR1_L
   \   000092                REQUIRE _A_PBIE_L
   \   000092                REQUIRE _A_PAIE_L
   \   000092                REQUIRE _A_TB0CCR2_L
   \   000092                REQUIRE _A_TB0IV_L
    125          
    126          
    127          //Timer Interrupt for movement and for counting expended time
    128          #pragma vector = TIMER1_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    129          __interrupt void Timer1_B0_ISR(void){
   \                     Timer1_B0_ISR:
   \   000000   0F12         PUSH.W  R15
    130          //------------------------------------------------------------------------------
    131          // TimerB1 0 Interrupt handler
    132          //----------------------------------------------------------------------------
    133            TB1CCR0 += TB1CCR0_INTERVAL; // Add Offset to TBCCR0
   \   000002   B25050C3D203 ADD.W   #0xc350, &0x3d2
    134            Movement_Timer_count++;
   \   000008   9253....     ADD.W   #0x1, &Movement_Timer_count
    135            counter_timer_count++;
   \   00000C   9253....     ADD.W   #0x1, &counter_timer_count
    136            circle_timer_count++;
   \   000010   9253....     ADD.W   #0x1, &circle_timer_count
    137            
    138            if (counter_timer_count>=second_count) {
   \   000014   B2900A00.... CMP.W   #0xa, &counter_timer_count
   \   00001A   0428         JNC     ??Timer1_B0_ISR_1
    139              Counter_Timer=Counter_Timer+incrementer;
   \   00001C   9253....     ADD.W   #0x1, &Counter_Timer
    140              counter_timer_count=RESET_STATE;
   \   000020   8243....     MOV.W   #0x0, &counter_timer_count
    141            }
    142            if (Movement_Timer_count>=second_count) {
   \                     ??Timer1_B0_ISR_1:
   \   000024   B2900A00.... CMP.W   #0xa, &Movement_Timer_count
   \   00002A   0428         JNC     ??Timer1_B0_ISR_2
    143              Movement_Timer=Movement_Timer+incrementer;
   \   00002C   9253....     ADD.W   #0x1, &Movement_Timer
    144              Movement_Timer_count=RESET_STATE;
   \   000030   8243....     MOV.W   #0x0, &Movement_Timer_count
    145            }
    146            if (circle_timer_count>=second_count){
   \                     ??Timer1_B0_ISR_2:
   \   000034   B2900A00.... CMP.W   #0xa, &circle_timer_count
   \   00003A   0428         JNC     ??Timer1_B0_ISR_3
    147              Circle_Timer=Circle_Timer+incrementer;
   \   00003C   9253....     ADD.W   #0x1, &Circle_Timer
    148              circle_timer_count=RESET_STATE;
   \   000040   8243....     MOV.W   #0x0, &circle_timer_count
    149            }
    150            if (circle_timer_flag && Circle_Timer>=second_count) {
   \                     ??Timer1_B0_ISR_3:
   \   000044   8293....     CMP.W   #0x0, &circle_timer_flag
   \   000048   0C24         JEQ     ??Timer1_B0_ISR_4
   \   00004A   B2900A00.... CMP.W   #0xa, &Circle_Timer
   \   000050   0828         JNC     ??Timer1_B0_ISR_4
    151              line_follower_state=line_follow;
   \   000052   B2400300.... MOV.W   #0x3, &line_follower_state
    152              traverse_state=pause;
   \   000058   B2400700.... MOV.W   #0x7, &traverse_state
    153              circle_timer_flag=RESET_STATE;
   \   00005E   8243....     MOV.W   #0x0, &circle_timer_flag
    154            }
    155            line_follower_timer_flag=!line_follower_timer_flag;  
   \                     ??Timer1_B0_ISR_4:
   \   000062   8293....     CMP.W   #0x0, &line_follower_timer_flag
   \   000066   0220         JNE     ??Timer1_B0_ISR_5
   \   000068   5F43         MOV.B   #0x1, R15
   \   00006A   013C         JMP     ??Timer1_B0_ISR_0
   \                     ??Timer1_B0_ISR_5:
   \   00006C   4F43         MOV.B   #0x0, R15
   \                     ??Timer1_B0_ISR_0:
   \   00006E   4F4F         MOV.B   R15, R15
   \   000070   824F....     MOV.W   R15, &line_follower_timer_flag
    156          //----------------------------------------------------------------------------
    157          }
   \   000074   3F41         POP.W   R15
   \   000076   0013         RETI
   \   000078                REQUIRE _A_TB1CCR0_L
    158          
    159          #pragma vector=TIMER1_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    160          __interrupt void TIMER1_B1_ISR(void){ 
   \                     TIMER1_B1_ISR:
   \   000000   0F12         PUSH.W  R15
    161          //----------------------------------------------------------------------------
    162          // TimerB0 1-2, Overflow Interrupt Vector (TBIV) handler
    163          //----------------------------------------------------------------------------
    164            switch(__even_in_range(TB1IV,OVERFLOW)){
   \   000002   1F42EE03     MOV.W   &0x3ee, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for TIMER1_B1_ISR>_0`:
   \   000008   0C3C         JMP     ??TIMER1_B1_ISR_1
   \   00000A   063C         JMP     ??TIMER1_B1_ISR_2
   \   00000C   0A3C         JMP     ??TIMER1_B1_ISR_1
   \   00000E   093C         JMP     ??TIMER1_B1_ISR_1
   \   000010   083C         JMP     ??TIMER1_B1_ISR_1
   \   000012   073C         JMP     ??TIMER1_B1_ISR_1
   \   000014   063C         JMP     ??TIMER1_B1_ISR_1
   \   000016   053C         JMP     ??TIMER1_B1_ISR_1
    165              case RESET_STATE: break; // No interrupt
    166              case CCR1:
    167                  ADCCTL0 |= ADCSC;
   \                     ??TIMER1_B1_ISR_2:
   \   000018   92D30007     BIS.W   #0x1, &0x700
    168                  TB1CCR1 += TB1CCR1_INTERVAL;
   \   00001C   B250C409D403 ADD.W   #0x9c4, &0x3d4
    169                  break;
    170              case CCR2: break;    
    171              case OVERFLOW: // overflow
    172                  break;
    173              default: break;
    174            }
    175          //----------------------------------------------------------------------------
    176          }
   \                     ??TIMER1_B1_ISR_1:
   \   000022   3F41         POP.W   R15
   \   000024   0013         RETI
   \   000026                REQUIRE _A_ADCCTL0_L
   \   000026                REQUIRE _A_TB1CCR1_L
   \   000026                REQUIRE _A_TB1IV_L

   \                                 In  segment INTVEC, offset 0x50, root
   \                     `??TIMER1_B1_ISR::??INTVEC 80`:
   \   000050   ....         DC16    TIMER1_B1_ISR

   \                                 In  segment INTVEC, offset 0x52, root
   \                     `??Timer1_B0_ISR::??INTVEC 82`:
   \   000052   ....         DC16    Timer1_B0_ISR

   \                                 In  segment INTVEC, offset 0x54, root
   \                     `??TIMER0_B1_ISR::??INTVEC 84`:
   \   000054   ....         DC16    TIMER0_B1_ISR

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??Timer0_B0_ISR::??INTVEC 86`:
   \   000056   ....         DC16    Timer0_B0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   TIMER0_B1_ISR
      6   TIMER1_B1_ISR
      4   Timer0_B0_ISR
      6   Timer1_B0_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  Movement_Timer_count
     146  TIMER0_B1_ISR
       2  TIMER0_B1_ISR::??INTVEC 84
      38  TIMER1_B1_ISR
       2  TIMER1_B1_ISR::??INTVEC 80
      58  Timer0_B0_ISR
       2  Timer0_B0_ISR::??INTVEC 86
     120  Timer1_B0_ISR
       2  Timer1_B0_ISR::??INTVEC 82
       2  _A_ADCCTL0_L
       2  _A_PAIE_L
       2  _A_PAOUT_L
       2  _A_PBIE_L
       2  _A_PBOUT_L
       2  _A_TB0CCR0_L
       2  _A_TB0CCR1_L
       2  _A_TB0CCR2_L
       2  _A_TB0IV_L
       2  _A_TB1CCR0_L
       2  _A_TB1CCR1_L
       2  _A_TB1IV_L
       2  circle_timer_count
       2  counter_timer_count
       2  debounce_counter
       2  display_update_count
       2  flag
       2  follow_flag
       2  iot_ready
       2  line_follower_timer_flag

 
  24 bytes in segment DATA16_AN
  18 bytes in segment DATA16_Z
   8 bytes in segment INTVEC
 362 bytes in segment ISR_CODE
 
 362 bytes of CODE  memory
   0 bytes of CONST memory (+  8 bytes shared)
  18 bytes of DATA  memory (+ 24 bytes shared)

Errors: none
Warnings: 1
